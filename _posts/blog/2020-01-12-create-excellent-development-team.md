---
layout: post
title: 简述如何写出靠谱稳定的代码
description: 靠谱的技术团队需要对程序开发的原则有共同的认知
category: blog
---

1. 首先遵循Dry原则，意思就是don’t repeat yourself，不要做重复的事情。

2. 意识形态要正确：那就是程序是由开发者控制的。开发者需要控制程序，而不是反过来，让管理者、生产负责人控制程序。唯一能控制程序的人就是编写它们的人。

3. 对程序所做的任何变更都应该是简洁快速的，并且是将系统从一个稳定点移动到另一个稳定点。宁可少完成一些内容，但要保证完成的部分质量优秀。一旦部署的内容中有错误，就会影响到生产数据，修复起来代价极高，十分浪费时间，而且修复如果必须人工来干预，极易引发二次错误。必须做好完备的测试。

4. 项目中每引入一个不确定因素都是赌博。选择新编程语言是赌博，使用新框架是赌博，采用新的应用部署方式是赌博，了解哪些作法是在冒险，哪些是程序的稳定因素，这是我们控制风险时需要知道的。我们不排斥尝试新事物，但我们一定要控制好风险的范围。

5. 每个项目都会有“在这个项目中我们不会解决的问题”列表，列表中的很多东西似乎很有诱惑力，但限定范围会帮助我们明确需求重点，使项目稳定可控。定义好哪些是当下要解决的，哪些是未来需要解决的，并将这些内容放在以后的项目列表中。

6. 使用简洁的接口拼合简单的部件，用清晰的接口把程序的若干模块组合成一个复杂的软件，使问题只是局限于某个局部，从而不会牵一发而动全身。

7. 设计要简洁，复杂度能低则低，越是简洁，程序的维护成本就越低。

8. 除非确无它法，否则不要编写庞大的程序。大主要是指体积大，复杂度高，程序大了维护成本也会增加。

9. 健壮源于透明与简洁，让程序的内部逻辑更加简单且易于理解。

10. 程序应该尽可能多地应付各种输入错误和自身运行错误，尽可能多地暴露执行错误的信息，如果实在没有办法，则让程序以一种容易诊断错误的方式停止。程序开发周期中有4分之3的时间都处于测试和调试阶段，此期间要尽量把每一模块可能出现的异常情况考虑到，并做好处理。

11. 不知道瓶颈，就乱优化代码，这是一个比乱加功能更损害设计的错误。

12. 系统是为了生产力而构建，也就是说，系统并不是玩具，不能只完成自己那一份，就丢到生产环境不用再操心了。需要考虑如何在生产中配置系统，需要考虑内部依赖，并进行限制，还需要让系统易用、易维护。

13. 生产环境与开发环境分离，不应该在生产环境进行调试工作。

14. 程序的运行是CPU指令的依序运行，程序经过编译成机器码后执行顺序就已经确定，单线程的执行中没有随机性，程序运行中的任何现象都可由计算机专业知识来解释。

15. 12-factor理论：https://12factor.net/zh_cn/

16. 系统建立在12-factor理论之上，模块之间要松散耦合，每个模块都有一个功能，并为了让系统的其他部分正常工作，而对这个功能进行管理。模块之间通过协议进行松散的通讯，也就是说在通讯中，各方都可以变更，只要仍旧通过不变的方式进行通讯。在设计协议时要考虑到未来的扩展问题，每个模块在设计时都要考虑依赖，各模块都可以随时替换掉，将其放在另一个系统中需要是仍然可用的。

17. 要避免会滋生紧密耦合的深层依赖架构，在模块太过巨大时需要将其作拆分处理，但也要避免一大堆太过细小的模块，要保持复用功能的能力，从而减少依赖，依赖越少，程序越易于维护。

18. 中间件只需传递数据，避免中间件对数据进行解析和诠释。

19. 系统设计偏好以幂等性实现信息传递，当从已知的稳定状态过渡到下一步状态，如果成功的话，会对一致性进行验证，然后保持在这种状态中，如果失败的话，就会进行重试，再来一次。这点对于分布式系统的尽力交付机制来说特别重要，因为在所有消息中拥有唯一ID，意味着超时状态下可以执行重试，并确保如果在接收系统中拥有执行日志的话，消息就不会被接收系统重复运行。

20. 遵循UNIX原则：每个工具只做好一件事情，避免在一个工具中增加更多功能，而是另起一个工具。

21. 代码正确比开发速度更重要，代码优雅比开发速度更重要，代码质量比开发速度更重要，其实速度真的不太重要。

22. 在执行算法和数据结构优化前要进行测量，确保优化是否起到了想要的作用。构建的系统应当能够在运行时收集自身状态指标，以便优化时作为参考。

23. 大多时候对代码格式的讨论是没有意义的，因为标准在制定时也是随意的，之后大家都来效仿。

24. Python不太适合大规模并发，因为Python默认解释器CPython实现时引入了GIL(Global Interpreter Lock)。需要明确的一点是GIL并不是Python的特性，像其中的另外一款解释器Jython就没有GIL，由于用了Java实现解释器，也就失去了利用社区众多C语言模块有用特性的机会，所以Jython比较小众。